# 常见面试题

## 0.1 + 0.2 === 0.3 ？为什么？{#decimal-sum}

```js
console.log(0.1 + 0.2); // 0.30000000000000004

console.log(0.1 + 0.2 === 0.3); // false
```

**为什么 `0.1 + 0.2 !== 0.3` 呢？**

我们知道，计算机中所有数据都是以二进制储存的，计算时需要把数据转换成二进制进行计算，再把结果转换成十进制。

而大多数小数的二进制都是无限循环的，根据 IEEE 754 标准，Number 类型使用 64 位固定长度来表示。

其中符号位为占 1 位，指数位占 11 位，尾数位占 52 位。

`0.1`
转成二进制:
`0.0001100110011001100110011001100110011001100110011001101...`

无限循环在截断时丢失精度，导致 `0.1 + 0.2` 不等于 `0.3`。

### 如何解决

1. 把计算数字乘以 10 的 N 次方倍相加再除以 10 的 N 次方，即可得到精确的结果。

```js
console.log((0.1 * 10 + 0.2 * 10) / 10); // 0.3
```

2. 利用 toFixed()

```js
function add(a, b) {
  return parseFloat((a + b).toFixed(2));
}
console.log(add(0.1, 0.2) === 0.3); // true
```

## == 和 === 有什么区别？{#equal-and-strict-equal}

1. 对于 string、number 等基础类型，== 和 === 是有区别的

- a）不同类型间比较，== 之比较 "转化成同一类型后的值" 看 "值" 是否相等，=== 如果类型不同，其结果就是不等。
- b）同类型比较，直接进行 "值" 比较，两者结果一样。
2. 对于 Array,Object 等高级类型，== 和 === 是没有区别的

进行 "指针地址" 比较

3. 基础类型与高级类型，== 和 === 是有区别的

- a）对于 ==，将高级转化为基础类型，进行 "值" 比较
- b）因为类型不同，=== 结果为 false
4. != 为 == 的非运算，!== 为 === 的非运算

```js
var num=1；

var str="1"；

var test=1；

test == num   //true　相同类型　相同值 

test === num  //true　相同类型　相同值 

test !== num  //false test与num类型相同，其值也相同,　非运算肯定是false 

num == str   //true 　把str转换为数字，检查其是否相等。 

num != str   //false  == 的 非运算 

num === str  //false  类型不同，直接返回false 

num !== str  //true   num 与 str类型不同 意味着其两者不等　非运算自然是true啦
```