# 常见面试题

## 0.1 + 0.2 === 0.3 ？为什么？{#decimal-sum}

```js
console.log(0.1 + 0.2); // 0.30000000000000004

console.log(0.1 + 0.2 === 0.3); // false
```

**为什么 `0.1 + 0.2 !== 0.3` 呢？**

我们知道，计算机中所有数据都是以二进制储存的，计算时需要把数据转换成二进制进行计算，再把结果转换成十进制。

而大多数小数的二进制都是无限循环的，根据 IEEE 754 标准，Number 类型使用 64 位固定长度来表示。

其中符号位为占 1 位，指数位占 11 位，尾数位占 52 位。

`0.1`
转成二进制:
`0.0001100110011001100110011001100110011001100110011001101...`

无限循环在截断时丢失精度，导致 `0.1 + 0.2` 不等于 `0.3`。

### 如何解决

1. 把计算数字乘以 10 的 N 次方倍相加再除以 10 的 N 次方，即可得到精确的结果。

```js
console.log((0.1 * 10 + 0.2 * 10) / 10); // 0.3
```

2. 利用 toFixed()

```js
function add(a, b) {
	return parseFloat((a + b).toFixed(2));
}
console.log(add(0.1, 0.2) === 0.3); // true
```

## == 和 === 有什么区别？{#equal-and-strict-equal}

在`JavaScript`中，`==` 和 `===` 都是用来比较两个值是否相等的运算符，但它们在比较时使用不同的类型检查和转换规则。

1. 对于基本数据类型，`==` 和 `===` 的主要区别在于 == 在比较时会进行类型转换，而 `===` 不会。

- a）不同类型间比较，`==` 之比较 "转化成同一类型后的值" 看 "值" 是否相等，`===` 如果类型不同，其结果就是不等。
- b）同类型比较，直接进行 "值" 比较，两者结果一样。

```js
const num = 1；
const str = "1"；
const test = 1；

console.log(test == num)   //true　相同类型　相同值
console.log(test === num)  //true　相同类型　相同值
console.log(test !== num)  //false test与num类型相同，其值也相同,　非运算肯定是false
console.log(num == str)  //true 　把str转换为数字，检查其是否相等。
console.log(num != str)  //false  == 的 非运算
console.log(num === str)  //false  类型不同，直接返回false
console.log(num !== str)  //true   num 与 str类型不同 意味着其两者不等　非运算自然是true啦
```

2. 对于复杂数据类型，无论是使用 `==` 还是 `===`，比较的都是引用地址，而不是值。当你比较两个对象时，实际比较的是它们是否引用了内存中的同一个位置。

```js
[] == [];             // false，因为两个空数组引用不同的内存地址
[] === [];            // false，同上
{} == {};             // false，两个空对象引用不同的内存地址
{} === {};            // false，同上

const obj1 = {};
const obj2 = obj1;

obj1 == obj2;         // true，因为它们引用同一个对象
obj1 === obj2;        // true，同上
```

对于复杂数据类型，`==` 和 `===` 之间没有实际的区别，因为不涉及类型转换问题。如果两个变量引用同一个对象或函数，则它们相等；如果它们引用不同的内存块，即使内容完全相同，它们也不相等。

因此，当比较基本数据类型时，`===` 比 `==` 更加可靠，因为它不会执行可能导致意外结果的类型强制转换。而对于复杂数据类型，两者没有区别，因为比较的是引用地址。
