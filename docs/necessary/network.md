# 网络基础知识

## HTTP 与 HTTPS 的基本概念 {#http-https}

### HTTP

- **HTTP**（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。
- **HTTP** 默认工作在 TCP 协议 80 端口，用户访问网站 http:// 打头的都是标准 **HTTP** 服务。
- **HTTP** 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了 Web 浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，**HTTP**协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。

::: info HTTP 的特点

- 无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作。
- 无连接：HTTP/1.1 之前，由于无状态特点，每次请求需要通过 TCP 三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。
- 基于请求和响应：基本的特性，由客户端发起请求，服务端响应。
- 简单快速、灵活。
- 通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性。
  :::

### HTTPS

- **HTTPS**（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。**HTTPS** 经由 **HTTP** 进行通信，但利用 SSL/TLS 来加密数据包。**HTTPS** 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

- **HTTPS** 默认工作在 TCP 协议 443 端口，它的工作流程一般如以下方式：

> 1、TCP 三次同步握手
>
> 2、客户端验证服务器数字证书
>
> 3、DH 算法协商对称加密算法的密钥、hash 算法的密钥
>
> 4、SSL 安全加密隧道协商完成
>
> 5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的 hash 算法进行数据完整性保护，保证数据不被篡改。

## HTTP 和 HTTPS 的区别 {#http-and-https-diff}

- **HTTP** 明文传输，数据都是未加密的，安全性较差，**HTTPS**（HTTP + SSL） 数据传输过程是加密的，安全性较好。
- 使用 **HTTPS** 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。
- **HTTP** 页面响应速度比 **HTTPS** 快，主要是因为 **HTTP** 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 **HTTPS** 除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。
- **HTTP** 和 **HTTPS** 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
- **HTTPS** 其实就是建构在 SSL/TLS 之上的 **HTTP** 协议，所以，要比较 HTTPS 比 **HTTP** 要更耗费服务器资源。

## HTTP 状态码 (**HTTP Status Code**) {#http-status-code}

HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)：
| 分类 | 分类描述 |
| :---: | :--------------------------------------------- |
| 1** | 信息，服务器收到请求，需要请求者继续执行操作 |
| 2** | 成功，操作被成功接收并处理 |
| 3** | 重定向，需要进一步的操作以完成请求 |
| 4** | 客户端错误，请求包含语法错误或无法完成请求 |
| 5\*\* | 服务器错误，服务器在处理请求的过程中发生了错误 |

### HTTP 状态码列表

| 状态码 | 状态码描述                                                                                                                                                       |
| :----: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|  100   | 继续。客户端继续响应其请求                                                                                                                                       |
|  101   | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议                                                                 |
|        |
|  200   | 请求成功。一般用于 GET 与 POST 请求                                                                                                                              |
|  201   | 已创建。成功请求并创建了新的资源                                                                                                                                 |
|  202   | 已接受。已经接受请求，但未处理完成                                                                                                                               |
|  203   | 非授权信息。请求成功。但返回的 meta 信息不在原始的服务器，而是一个副本                                                                                           |
|  204   | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档                                                                         |
|  205   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域                                                               |
|  206   | 部分内容。服务器成功处理了部分 GET 请求                                                                                                                          |
|        |
|  300   | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择                                                           |
|  301   | 永久移动。请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替                              |
|  302   | 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI                                                                                            |
|  303   | 查看其它地址。与 301 类似。使用 GET 和 POST 请求查看                                                                                                             |
|  304   | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
|  305   | 使用代理。所请求的资源必须通过代理访问                                                                                                                           |
|  306   | 已经被废弃的 HTTP 状态码                                                                                                                                         |
|  307   | 临时重定向。与 302 类似。使用 GET 请求重定向                                                                                                                     |
|        |
|  400   | 客户端请求的语法错误，服务器无法理解                                                                                                                             |
|  401   | Unauthorized 请求要求用户的身份认证                                                                                                                              |
|  402   | 保留，将来使用                                                                                                                                                   |
|  403   | 服务器理解请求客户端的请求，但是拒绝执行此请求                                                                                                                   |
|  404   | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面                                                     |
|  405   | 客户端请求中的方法被禁止                                                                                                                                         |
|  406   | 服务器无法根据客户端请求的内容特性完成请求                                                                                                                       |
|  407   | 请求要求代理的身份认证，与 401 类似，但请求者应当使用代理进行授权                                                                                                |
|  408   | 服务器等待客户端发送的请求时间过长，超时                                                                                                                         |
|  409   | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突                                                                                          |
|  410   | 客户端请求的资源已经不存在。410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置                           |
|  411   | 服务器无法处理客户端发送的不带 Content-Length 的请求信息                                                                                                         |
|  412   | 客户端请求信息的先决条件错误                                                                                                                                     |
|  413   | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个 Retry-After 的响应信息  |
|  414   | 请求的 URI 过长（URI 通常为网址），服务器无法处理                                                                                                                |
|  415   | 服务器无法处理请求附带的媒体格式                                                                                                                                 |
|  416   | 客户端请求的范围无效                                                                                                                                             |
|  417   | 服务器无法满足 Expect 的请求头信息                                                                                                                               |
|        |
|  500   | 服务器内部错误，无法完成请求                                                                                                                                     |
|  501   | 服务器不支持请求的功能，无法完成请求                                                                                                                             |
|  502   | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应                                                                                   |
|  503   | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中                                                            |
|  504   | 充当网关或代理的服务器，未及时从远端服务器获取请求                                                                                                               |
|  505   | 服务器不支持请求的 HTTP 协议的版本，无法完成处理                                                                                                                 |

## 浏览器从 URL 输入到页面显示过程发生了什么？{#browser-page-process}

1. 解析 URL：首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。
2. 缓存判断：浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。
3. [DNS 解析](#DNS): 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。
4. 获取 MAC 地址： 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。
5. TCP 三次握手： 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向客户端发送一个 SYN ACK 报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。
6. HTTPS 握手： 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。
7. 返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。
8. 页面渲染： 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。
9. TCP 四次挥手： 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。

## 什么是 DNS？{#DNS}

**域名系统**（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。

## 什么是 TCP 协议？{#TCP}

**传输控制协议**（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。

### TCP 的特性

- TCP 提供一种面向连接的、可靠的字节流服务
- 在一个 TCP 连接中，仅有两方进行彼此通信。
- TCP 使用校验和，确认和重传机制来保证可靠传输
- TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复
- TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制

::: tip 注意
TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。
:::

## HTTP 与 TCP 区别 {#http-and-tcp-diff}

TCP 协议对应于传输层，而 HTTP 协议对应于应用层，从本质上来说，二者没有可比性：

- HTTP 对应于应用层，TCP 协议对应于传输层
- HTTP 协议是在 TCP 协议之上建立的，HTTP 在发起请求时通过 TCP 协议建立起连接服务器的通道，请求结束后，立即断开 TCP 连接
- HTTP 是无状态的短连接，而 TCP 是有状态的长连接
- TCP 是传输层协议，定义的是数据传输和连接方式的规范，HTTP 是应用层协议，定义的是传输数据的内容的规范
  ::: info 说明
  从 HTTP/1.1 起，默认都开启了 Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接 Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件(如 Apache)中设定这个时间。
  :::

## 三次握手和四次挥手 {#three-and-four-handshakes}

![图示](/images/tcp3-4.png)

### 三次握手

1. 第一次：客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 `SYN-SENT 状态`(表示请求连接)。

2. 第二次：服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 `SYN-RECEIVED 状态`（收到来自对端的 SYN 请求，并回复 SYN 请求后，等待对端响应 SYN 请求的 ACK 消息）。

3. 第三次：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 `ESTABLISHED 状态`(代表连接建立，双方在这个状态下进行 TCP 数据交互)，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。

### 四次挥手

1. 第一次：若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。

2. 第二次：B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。

3. 第三次：B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。

::: info 提示
通过延迟确认的技术(通常有时间限制，否则对方会误认为需要重传)，可以将第二次和第三次握手合并，延迟 ACK 包的发送。
:::

4. 第四次：A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL(最长报文段寿命，指报文段在网络中生存的时间，超时会被抛弃) 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。

## 什么是同源策略？{#same-origin-policy}

`同源策略`是一个重要的安全策略，它用于限制一个 origin 的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。
它是浏览器核心也最基本的安全功能，它会阻止一个域的 js 脚本和另外一个域的内容进行交互，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。
所谓同源（即在同一个域）就是两个页面具有相同的协议（protocol）、主机（host）和端口号（port）。

## 浏览器缓存机制：强缓存和协商缓存 {#browser-caching}

**缓存**是一种数据存储技术，是指浏览器（客户端）在本地磁盘中对访问过的资源保存的副本文件。

浏览器缓存（Browser Caching）有以下几个特点：

✅ 减少重复数据请求，避免通过网络再次加载资源，节省流量。

✅ 降低服务器的压力，提升网站性能。

✅ 加快客户端加载网页的速度， 提升用户体验。

❌ 资源如果有更改但是客户端不及时更新会造成用户获取信息滞后。

浏览器缓存分为强缓存和协商缓存，两者有两个比较明显的区别：

- 如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信，与服务器进行对比。
- 在 chrome 命中强缓存（虽然没有发出真实的 http 请求）的请求状态码返回是 200 (from cache)；而协商缓存如果命中走缓存的话，请求的状态码是 304 (not modified)。

### 请求流程

浏览器在第一次请求后缓存资源，再次请求时，会进行下面两个步骤：

- 浏览器会获取该缓存资源的 header 中的信息，根据 response header 中的 expires 和 cache-control 来判断是否命中强缓存，如果命中则直接从缓存中获取资源。
- 如果没有命中强缓存，浏览器就会发送请求到服务器，这次请求会带上 IF-Modified-Since 或者 IF-None-Match, 它们的值分别是第一次请求返回 Last-Modified 或者 Etag，由服务器来对比这一对字段来判断是否命中。如果命中，则服务器返回 304 状态码，并且不会返回资源内容，浏览器会直接从缓存获取；否则服务器最终会返回资源的实际内容，并更新 header 中的相关缓存字段

![web-cache](/images/web-cache.png)

### 强缓存

强缓存是根据返回头中的 Expires 或者 Cache-Control 两个字段来控制的，都是表示资源的缓存有效时间。

1. expires

Expires 是 http 1.0 的规范，值是一个 GMT 格式的时间点字符串，比如 Expires:Mon,18 Oct 2066 23:59:59 GMT 。这个时间点代表资源失效的时间，如果当前的时间戳在这个时间之前，则判定命中缓存。有一个缺点是，失效时间是一个绝对时间，如果服务器时间与客户端时间偏差较大时，就会导致缓存混乱。而服务器的时间跟用户的实际时间是不一样是很正常的，所以 Expires 在实际使用中会带来一些麻烦。

2. Cache-Control
```js
Cache-Control: public,max-age=3600,s-maxage=3600
```
Cache-Control 这个字段是 http 1.1 的规范，如果 Cache-Control 与 Expires 同时存在的话， Cache-Control 的优先级高于 Expires。

一般常用该字段的 max-age 值来进行判断，它是一个相对时间，比如 Cache-Control:max-age=3600 代表资源的有效期是 3600 秒。并且返回头中的 Date 表示消息发送的时间，表示当前资源在 Date ~ Date +3600s 这段时间里都是有效的。不过我在实际使用中常常遇到设置了 max-age 之后，在 max-age 时间内重新访问资源却会返回 304 not modified ，这是由于服务器的时间与本地的时间不同造成的。
- max-age和s-maxage，是一个数字, 表示资源过了多少秒后变为无效。在浏览器中，max-age和s-maxage都起作用，且s-maxage的优先级高于max-age。在代理服务器中，只有s-maxage起作用。可以通过设置max-age为0表示立即过期来向服务器请求资源。
- no-cache 不使用本地缓存。需要使用协商缓存。
- no-store 直接禁止浏览器缓存数据，每次请求资源都会向服务器要完整的资源， 类似于 network 中的 disabled cache。
- public 可以被所有用户缓存，包括终端用户和 cdn 等中间件代理服务器。
- private 只能被终端用户的浏览器缓存。
- pragma 它的值有​​no-cache​​​和​​no-store​​​, 表示意思同​​cache-control​​​, 优先级高于​​cache-control​​​和​​expires​​​, 即三者同时出现时, ​pragma​​ ​-> ​​cache-control​ ​​-> ​​expires​​。

### 协商缓存

协商缓存是由服务器来确定缓存资源是否可用。 主要涉及到两对属性字段，都是成对出现的，即第一次请求的响应头带上某个字, `Last-Modified` 或者 `Etag`，则后续请求则会带上对应的请求字段 `If-Modified-Since`或者 `If-None-Match`，若响应头没有 `Last-Modified` 或者 `Etag` 字段，则请求头也不会有对应的字段。

- `Last-Modified`/`If-Modified-Since` 二者的值都是GMT格式的时间字符串， `Last-Modified` **标记最后文件修改时间**， 下一次请求时，请求头中会带上 `If-Modified-Since` 值就是 `Last-Modified` 告诉服务器我本地缓存的文件最后修改的时间，在服务器上根据文件的最后修改时间判断资源是否有变化， 如果文件没有变更则返回 304 Not Modified ，请求不会返回资源内容，浏览器直接使用本地缓存。当服务器返回 304 Not Modified 的响应时，response header 中不会再添加的 `Last-Modified` 去试图更新本地缓存的 `Last-Modified`， 因为既然资源没有变化，那么 `Last-Modified` 也就不会改变；如果资源有变化，就正常返回返回资源内容，新的 `Last-Modified` 会在 response header 返回，并在下次请求之前更新本地缓存的 `Last-Modified`，下次请求时，`If-Modified-Since`会启用更新后的 `Last-Modified`。

- `Etag`/`If-None-Match`， 值都是由服务器为每一个资源生成的唯一标识串，只要资源有变化就这个值就会改变。服务器根据文件本身算出一个哈希值并通过 `ETag`字段返回给浏览器，接收到 `If-None-Match` 字段以后，服务器通过比较两者是否一致来判定文件内容是否被改变。与 `Last-Modified` 不一样的是，当服务器返回 304 Not Modified 的响应时，由于在服务器上`ETag` 重新计算过，response header中还会把这个 `ETag` 返回，即使这个 `ETag` 跟之前的没有变化。

:::info 为什么要有 Etag
HTTP1.1 中 Etag 的出现主要是为了解决几个 Last-Modified 比较难解决的问题：
- 一些文件也许会周期性的更改，但是内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
- 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since 能检查到的粒度是秒级的，使用 Etag 就能够保证这种需求下客户端在1秒内能刷新 N 次 cache。
- 某些服务器不能精确的得到文件的最后修改时间。
:::

:::tip 浏览器缓存总的优先级
 **Cache-Control**  > **expires** > **Etag** > **Last-Modified**
:::